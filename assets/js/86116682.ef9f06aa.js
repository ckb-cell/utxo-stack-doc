"use strict";(self.webpackChunkutxo_stack_website=self.webpackChunkutxo_stack_website||[]).push([[453],{6963:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var n=a(4848),i=a(8453);const s={sidebar_position:4,title:"DA Layer"},o="UTXO Stack Data Availability Layer",l={id:"da-layer",title:"DA Layer",description:"Data Availability (DA) layer solves the data availability problem in a trust-minimized way by leveraging the data availability sampling protocol.",source:"@site/docs/da-layer.md",sourceDirName:".",slug:"/da-layer",permalink:"/utxo-stack-doc/docs/da-layer",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"DA Layer"},sidebar:"docsSidebar",previous:{title:"App Chain",permalink:"/utxo-stack-doc/docs/app-chain"},next:{title:"Cross-Chain Interoperability",permalink:"/utxo-stack-doc/docs/cross-chain"}},r={},h=[{value:"DA chain",id:"da-chain",level:2},{value:"Header",id:"header",level:3},{value:"Submit data",id:"submit-data",level:3},{value:"DA proof",id:"da-proof",level:3},{value:"Pruning",id:"pruning",level:2},{value:"Data availability sampling",id:"data-availability-sampling",level:2},{value:"References",id:"references",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"utxo-stack-data-availability-layer",children:"UTXO Stack Data Availability Layer"}),"\n",(0,n.jsx)(t.p,{children:"Data Availability (DA) layer solves the data availability problem in a trust-minimized way by leveraging the data availability sampling protocol."}),"\n",(0,n.jsx)(t.p,{children:"The UTXO Stack DA layer leverages light clients to perform data sampling. Therefore, light client nodes constantly sample data shares from full nodes and broadcast shares if they are valid. If there are enough light clients in the network, we can be confident that an honest full node can collect enough shares to reconstruct the full data."}),"\n",(0,n.jsxs)(t.p,{children:["UTXO Stack and RGB++ provide an exit strategy in case of a DA attack, as detailed in the ",(0,n.jsx)(t.a,{href:"/utxo-stack-doc/docs/da-exit",children:"DA exit"})," documentation. Although the asset security does not depend solely on the security of the DA layer, using the DA layer still has some advantages:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Increases the cost of malicious attacks:"})," Attackers must simultaneously attack the DA layer and the branch chain to manipulate assets."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Reduces the cost of challenges:"})," The DA layer supports data retrieval through light clients and data availability sampling (DAS), which significantly lowers the cost of running a challenge node. This approach not only makes it more economical to maintain challenge nodes but also enhances the overall security and reliability of the network by making it easier for more participants to engage in the challenge process."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Concentrates staking:"})," All branch chains's staked value comes from the DA layer. The combined staking value from all branch chains contributes to the security of the DA layer, creating a more robust and resilient system."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"da-chain",children:"DA chain"}),"\n",(0,n.jsx)(t.h3,{id:"header",children:"Header"}),"\n",(0,n.jsx)(t.p,{children:"The DA chain uses a similar architecture to the branch chain, but extends the consensus mechanism and P2P network protocols to support the DA layer functionality."}),"\n",(0,n.jsx)(t.p,{children:"The DA chain's block structure is consistent with the branch chain. However, the meaning of the tx_root field has changed. In the DA chain, the new field da_tx_root is calculated from the tx_root and the tx_blob_root using merkle_hash(tx_root, tx_blob_root). This modification allows the DA chain to generate Merkle proofs for blobs, which are used in data sampling and data submission verification."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"// branch chain\nlet tx_root = merkle_hash(txs);\n\n// DA chain\nlet tx_root = merkle_hash(txs);\nlet tx_blob_root = merkle_hash(txs.map(|tx| merkle_hash(tx.blobs)))\nlet da_tx_root = merkle_hash([tx_root, tx_blob_root]);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The P2P message protocol is extended to additionally broadcast the list of Blobs contained in the Block when transmitting the Block. ",(0,n.jsx)(t.code,{children:"DA chain validators"})," must wait to receive the complete Block and the complete Blobs before verifying the da_tx_root. If everything is valid, they can then continue to verify and sign the block."]}),"\n",(0,n.jsx)(t.h3,{id:"submit-data",children:"Submit data"}),"\n",(0,n.jsxs)(t.p,{children:["The DA chain has a built-in ",(0,n.jsx)(t.code,{children:"Dummy Type ID - Data Store"})," in the Genesis, which is used to mark whether a transaction has submitted Blobs. The Data Store rules are verified by the consensus."]}),"\n",(0,n.jsxs)(t.p,{children:["If a DA chain transaction submits data, the first output's type_script must use the Data Store contract, and the output's cell data field must be the 32-byte ",(0,n.jsx)(t.code,{children:"merkle_hash(blobs)"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Branch chain consensus nodes utilize the ",(0,n.jsx)(t.code,{children:"submit_tx_with_blobs"})," interface when submitting chain data (e.g. branch chain transactions), along with the blobs list. The DA validators will check if the Blobs submission information is consistent with the related transaction, and if so, they will broadcast the transaction and Blobs."]}),"\n",(0,n.jsxs)(t.p,{children:["DA validators thoroughly verify each block by calculating the ",(0,n.jsx)(t.code,{children:"blob_root"})," for each transaction and comparing it to the ",(0,n.jsx)(t.code,{children:"da_tx_root"}),". If any discrepancies are found, the block is rejected."]}),"\n",(0,n.jsx)(t.p,{children:"The Blob structure is as follows:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub struct Blob {\n    version: u32,\n    data: Bytes,\n}\n\npub struct TxWithBlob {\n    tx: Tx,\n    blobs: Vec<Blob>\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"da-proof",children:"DA proof"}),"\n",(0,n.jsxs)(t.p,{children:["After a DA chain transaction is packaged, branch chain nodes can provide a Merkle proof based on the ",(0,n.jsx)(t.code,{children:"da_tx_root"})," in a block header to cryptographically prove that a specific blob has been submitted to the DA chain:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["The branch chain block header must save the Merkle root of the submitted blobs - ",(0,n.jsx)(t.code,{children:"da_blobs_root"}),"."]}),"\n",(0,n.jsx)(t.li,{children:"After the DA Chain has packaged the blobs, one can obtain the DA chain block header and the Merkle proof for the da_blobs_root."}),"\n",(0,n.jsx)(t.li,{children:"An on-chain DA light client on CKB can be invoked to verify the Merkle Proof, to prove that the branch chain data has been submitted to the DA layer."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"pruning",children:"Pruning"}),"\n",(0,n.jsx)(t.p,{children:'DA chain Nodes with pruning enabled will periodically delete block and blob data, keeping only the block headers. This saves significant disk space.\nNodes can be set to "archive mode" to persist the full data.'}),"\n",(0,n.jsx)(t.h2,{id:"data-availability-sampling",children:"Data availability sampling"}),"\n",(0,n.jsx)(t.p,{children:"Data availability sampling (DAS) is a crucial technique used by the DA chain to ensure the availability and retrievability of block data and blobs."}),"\n",(0,n.jsxs)(t.p,{children:["DA chain nodes use Reed-Solomon erasure coding to split the block data and blobs into multiple shares. These shares are organized into a 2D matrix structure using a ",(0,n.jsx)(t.code,{children:"2D Reed-Solomon Encoded Merkle tree"}),". This generates the ",(0,n.jsx)(t.code,{children:"dataRoot"})," of each row and column in the 2D matrix."]}),"\n",(0,n.jsxs)("figure",{align:"center",children:[(0,n.jsx)("img",{src:"/img/da-layer/2D-Reed-Solomon-Encoded-Merkle-tree.jpeg",alt:"2D Reed-Solomon Encoded Merkle tree"}),(0,n.jsx)("figcaption",{align:"center",children:(0,n.jsx)(t.a,{href:"https://arxiv.org/abs/1809.09044",children:"original paper"})})]}),"\n",(0,n.jsx)(t.p,{children:"The DA chain light clients randomly select a set of coordinates to query shares from full nodes. If the full nodes return valid shares, it indicates that the data is most likely available. They continuously request shares from the DA chain full nodes and propagate them through the P2P gossip protocol."}),"\n",(0,n.jsx)(t.p,{children:"As a result, honest full nodes have a high probability of obtaining enough shares (i.e., at least \ud835\udc58\xd7\ud835\udc58 unique shares) from the P2P network to recover the complete data."}),"\n",(0,n.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://arxiv.org/abs/1809.09044",children:"Fraud and Data Availability Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://docs.celestia.org/learn/how-celestia-works/data-availability-layer",children:"Celestia's data availability layer"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://dankradfeist.de/ethereum/2019/12/20/data-availability-checks.html",children:"Data availability checks using erasure codes"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>l});var n=a(6540);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);